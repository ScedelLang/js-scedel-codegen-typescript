import path from 'node:path';
import { TypeScriptCodegenOptions } from './typescript-codegen-options.js';

export class TypeScriptCodeGenerator {
  generate(repository, options = new TypeScriptCodegenOptions()) {
    const resolvedOptions = options instanceof TypeScriptCodegenOptions
      ? options
      : new TypeScriptCodegenOptions(options);

    const files = [];
    const warnings = [];

    for (const typeDefinition of repository.customTypes()) {
      if (isIgnored(typeDefinition.annotations)) {
        continue;
      }

      if (!isRecordLike(typeDefinition.expr)) {
        warnings.push({
          code: 'SKIPPED_NON_RECORD',
          typeName: typeDefinition.name,
          fieldName: null,
          message: 'Only record-like types are generated to TypeScript files.',
        });
        continue;
      }

      const renderContext = resolveRenderContext(typeDefinition, resolvedOptions);
      const outputPath = path.join(renderContext.outputDir, renderContext.fileName);

      const source = renderTypeSource(typeDefinition, renderContext, resolvedOptions, repository);
      files.push({ path: outputPath, contents: source });
    }

    return { files, warnings };
  }
}

function resolveRenderContext(typeDefinition, options) {
  const annotation = (key) =>
    typeDefinition.annotations?.[`js.codegen.${key}`]
    ?? typeDefinition.annotations?.[`ts.codegen.${key}`]
    ?? null;

  const outputDir = annotation('dir') ?? options.outputDir;
  const namespace = annotation('namespace') ?? options.defaultNamespace;
  const className = annotation('class') ?? typeDefinition.name;
  const fileName = annotation('file') ?? `${className}.ts`;

  return {
    outputDir,
    namespace,
    className,
    fileName,
  };
}

function renderTypeSource(typeDefinition, context, options, repository) {
  const fields = collectFields(typeDefinition, repository);
  const lines = [];

  lines.push('// Auto-generated by @scedel/codegen-typescript');
  lines.push(`// Source type: ${typeDefinition.name}`);
  lines.push(`// Namespace hint: ${context.namespace}`);
  lines.push('');

  if (options.generateConstructors) {
    lines.push(`export class ${context.className} {`);
    for (const field of fields) {
      lines.push(`  ${field.name}${field.optional ? '?' : ''}: ${field.tsType};`);
    }

    lines.push('');
    lines.push('  constructor(data = {}) {');
    lines.push('    Object.assign(this, data);');
    lines.push('  }');
    lines.push('}');
  } else {
    lines.push(`export interface ${context.className} {`);
    for (const field of fields) {
      lines.push(`  ${field.name}${field.optional ? '?' : ''}: ${field.tsType};`);
    }
    lines.push('}');
  }

  lines.push('');
  return lines.join('\n');
}

function collectFields(typeDefinition, repository) {
  const merged = new Map();
  collectFieldsFromExpr(
    typeDefinition.expr,
    typeDefinition,
    repository,
    merged,
    new Set([typeDefinition.name]),
  );
  return [...merged.values()];
}

function collectFieldsFromExpr(typeExpr, ownerType, repository, merged, stack) {
  if (typeExpr.kind === 'record') {
    for (const field of typeExpr.fields) {
      const inlineIgnored = field.annotations?.some((annotation) =>
        annotation.key === 'js.ignore' || annotation.key === 'ts.ignore');
      const targetedFieldAnnotations = ownerType?.fieldAnnotations?.[field.name] ?? {};
      const targetedIgnored =
        targetedFieldAnnotations['js.ignore'] === 'true'
        || targetedFieldAnnotations['ts.ignore'] === 'true';

      if (inlineIgnored || targetedIgnored) {
        continue;
      }

      merged.set(field.name, {
        name: field.name,
        optional: field.optional,
        tsType: mapTypeToTs(field.type, repository, stack),
      });
    }

    return;
  }

  if (typeExpr.kind === 'intersection') {
    for (const member of typeExpr.members) {
      if (member.kind === 'named') {
        if (stack.has(member.name)) {
          continue;
        }

        const nested = repository.getType(member.name);
        if (nested && !nested.isBuiltin) {
          const nextStack = new Set(stack);
          nextStack.add(member.name);
          collectFieldsFromExpr(nested.expr, nested, repository, merged, nextStack);
          continue;
        }
      }

      collectFieldsFromExpr(member, ownerType, repository, merged, stack);
    }
  }
}

function isRecordLike(typeExpr) {
  return typeExpr.kind === 'record' || (typeExpr.kind === 'intersection' && typeExpr.members.some((member) => member.kind === 'record' || member.kind === 'named'));
}

function mapTypeToTs(typeExpr, repository, stack) {
  if (!typeExpr || typeof typeExpr !== 'object') {
    return 'unknown';
  }

  switch (typeExpr.kind) {
    case 'named': {
      if (SchemaBuiltin(typeExpr.name)) {
        return mapNamedType(typeExpr.name);
      }

      if (repository.getType(typeExpr.name)) {
        return typeExpr.name;
      }

      return mapNamedType(typeExpr.name);
    }

    case 'nullableNamed':
      return `${mapTypeToTs({ kind: 'named', name: typeExpr.name }, repository, stack)} | null`;

    case 'nullable':
      return `${mapTypeToTs(typeExpr.inner, repository, stack)} | null`;

    case 'array':
      return `${mapTypeToTs(typeExpr.itemType, repository, stack)}[]`;

    case 'dict':
      return `Record<${mapTypeToTs(typeExpr.keyType, repository, stack)}, ${mapTypeToTs(typeExpr.valueType, repository, stack)}>`;

    case 'record':
      return `{ ${typeExpr.fields.map((field) => `${field.name}${field.optional ? '?' : ''}: ${mapTypeToTs(field.type, repository, stack)}`).join('; ')} }`;

    case 'union':
      return typeExpr.members.map((member) => mapTypeToTs(member, repository, stack)).join(' | ');

    case 'intersection':
      return typeExpr.members.map((member) => mapTypeToTs(member, repository, stack)).join(' & ');

    case 'literal':
      return JSON.stringify(typeExpr.value);

    case 'absent':
      return 'undefined';

    case 'conditional':
      return `${mapTypeToTs(typeExpr.thenType, repository, stack)} | ${mapTypeToTs(typeExpr.elseType, repository, stack)}`;

    default:
      return 'unknown';
  }
}

function SchemaBuiltin(name) {
  return [
    'Int', 'Uint', 'Short', 'Ushort', 'Long', 'Ulong', 'Byte', 'Ubyte',
    'Float', 'Double', 'Decimal',
    'Bool', 'True', 'False',
    'String', 'Url', 'Email', 'Uuid', 'Base64', 'Date', 'DateTime', 'Time', 'Duration',
    'Ip', 'IpV4', 'IpV6',
    'Binary', 'Null', 'Any', 'Array',
  ].includes(name);
}

function mapNamedType(name) {
  switch (name) {
    case 'Int':
    case 'Uint':
    case 'Short':
    case 'Ushort':
    case 'Long':
    case 'Ulong':
    case 'Byte':
    case 'Ubyte':
    case 'Float':
    case 'Double':
    case 'Decimal':
      return 'number';
    case 'Bool':
    case 'True':
    case 'False':
      return 'boolean';
    case 'String':
    case 'Url':
    case 'Email':
    case 'Uuid':
    case 'Base64':
    case 'Date':
    case 'DateTime':
    case 'Time':
    case 'Duration':
    case 'Ip':
    case 'IpV4':
    case 'IpV6':
    case 'Binary':
      return 'string';
    case 'Null':
      return 'null';
    case 'Any':
      return 'unknown';
    default:
      return name;
  }
}

function isIgnored(annotations = {}) {
  return annotations['ts.ignore'] === 'true' || annotations['js.ignore'] === 'true';
}
